#include "Assets/Util/Util.hlsl"

struct Agent
{
    float2 pos;
    float angle;
    int specieIndex;
};

struct Specie
{
    float moveSpeed;
    float turnSpeed;

    float3 mask;
    float sensorAngleOffset;
    float sensorDistanceOffset;
    int sensorSize;
        
    float3 color;
};

RWTexture2D<float4> TrailMap, DiffusedTrailMap;
float width, height, midX, midY, time, deltaTime, diffusionRate;

RWStructuredBuffer<Agent> agents;
StructuredBuffer<Specie> species;

float sense(Agent agent, float sensorDegreeMultiplier)
{
    const Specie specie = species[agent.specieIndex];
    const float2 sensorMid = agent.pos + getDir(agent.angle + specie.sensorAngleOffset*sensorDegreeMultiplier) * specie.sensorDistanceOffset;
    const int sensorX = sensorMid.x;
    const int sensorY = sensorMid.y;
    // const int startX = limitWithinRange(sensorX-specie.sensorSize, 0, width);
    // const int endX = limitWithinRange(sensorX+specie.sensorSize, 0, width);
    // const int startY = limitWithinRange(sensorY-specie.sensorSize, 0, height);
    // const int endY = limitWithinRange(sensorY+specie.sensorSize, 0, height);
    float sum = 0;

    float4 senseWeight = float4(specie.mask, 1) * 2 - 1;
    
    for(int offsetX = -specie.sensorSize; offsetX < specie.sensorSize; ++offsetX)
    {
        for(int offsetY = -specie.sensorSize; offsetY < specie.sensorSize; ++offsetY)
        {
            int sampleX = limitWithinRange(sensorX + offsetX, 0, width-1);
            int sampleY = limitWithinRange(sensorY + offsetY, 0, height-1);
            sum += dot(senseWeight, TrailMap[int2(sampleX, sampleY)]);
        }
    }
    
    return sum;
}

#pragma kernel Update

[numthreads(32,1,1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    Agent agent = agents[id.x];
    Specie specie = species[agent.specieIndex];
    
    float random = scaleToRange01(hash(time*id.x));

    float weightLeft = sense(agent, -1);
    float weightForward = sense(agent, 0);
    float weightRight = sense(agent, 1);
    float weight = max(max(weightLeft, weightForward), weightRight);

    if(weight == weightLeft)
        agent.angle = approachValue(agent.angle, agent.angle - specie.sensorAngleOffset, specie.turnSpeed);
    else if(weight == weightRight)
        agent.angle = approachValue(agent.angle, agent.angle + specie.sensorAngleOffset, specie.turnSpeed);

    // if(weight == weightLeft)
    //     agent.angle -= specie.turnSpeed*random;
    // else if(weight == weightRight)
    //     agent.angle += specie.turnSpeed*random;
    
    // weight = limitWithinRange(sqrt(weight), 1, 1.523f);

    float2 direction = getDir(agent.angle);
    float2 newPos = agent.pos + direction * specie.moveSpeed * deltaTime;

    while(isOutside(newPos.x, newPos.y, width, height))
    {
        agent.angle = random * 2 * 3.1415;
        direction = getDir(agent.angle);
        newPos = agent.pos + direction * specie.moveSpeed * 10 * deltaTime;
    }
    // if(isOutside(newPos.x, newPos.y, width, height))
    //     newPos = float2(midX, midY);
    
    agent.pos = newPos;
    TrailMap[int2(agent.pos.x, agent.pos.y)] = float4(specie.color, 1);
    // TrailMap[int2(agent.pos.x, agent.pos.y)] = float4(agent.angle%1, (agent.angle*1.5)%1, (agent.angle*2.25)%1, 1);
    // TrailMap[int2(agent.pos.x, agent.pos.y)] = float4((agent.angle*20)%1, newPos.x/width, newPos.y/height, 1);
    // TrailMap[int2(agent.pos.x, agent.pos.y)] = float4(agent.speed/1000, (agent.angle*agent.speed)%0.5, agent.speed/10000, 1);
    
    // float x = id.x / width;
    // float y = id.y / height;
    // Result[id.xy] = float4(sin(x), cos(x), tan(x + y), 1);
    
    agents[id.x] = agent;
}

#pragma kernel Diffuse

[numthreads(8,8,1)]
void Diffuse(uint3 id : SV_DispatchThreadID)
{
    // const float4 originalCol = TrailMap[id.xy];
    float4 sum = 0;
    // 3x3 blur
    for(int offsetX = -1; offsetX <= 1; ++offsetX)
    {
        for(int offsetY = -1; offsetY <= 1; ++offsetY)
        {
            sum += TrailMap[int2
                (
                    limitWithinRange(id.x + offsetX, 0, width-1),
                    limitWithinRange(id.y + offsetY, 0, height-1)
                )];
        }
    }

    float4 blurredCol = sum / 9;
    blurredCol = float4(blurredCol.x, blurredCol.y, blurredCol.z, 1);
    // float diffuseWeight = saturate(diffuseRate * deltaTime);
    // blurredCol = originalCol * (1 - diffuseWeight) + blurredCol * (diffuseWeight);
    DiffusedTrailMap[id.xy] = max(0, blurredCol - diffusionRate * deltaTime);
}

// #pragma kernel Color
//
// [numthreads(8,8,1)]
// void Color(uint3 id : SV_DispatchThreadID)
// {
//     float greyscale = DiffusedTrailMap[id.xy].x;
//     TrailMap[id.xy] = 1;
// }